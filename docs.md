# Documentation
Feel free to use this official documentation as heavily or lightly as you like as you build the applications of the future, with a little help from Membrane.
- ### Aliases
Aliases are *the* fundamental property of Membrane peers. They define unique peer identities, and come in two flavors: hidden and public. 
  - `hiddenAliases` are used heavily in internal transactions and routing, acting as formal universally-unique-identifiers for peers. 
  - Meanwhile `publicAliases` act as a user-definable skin which translates directly into hidden aliases, and vice-versa, allowing for some ammount of identity-customization.  
###
These two are correlated by the object `hiddenAliasLookup`, for finding a `hiddenAlias`'s `publicAlias`, while `publicAliasLookup` does the opposite.
- ### Config
  - #### Loading custom configurations:
    Global preferences are loaded into the `CONFIG` object when the script is first initialized. The pre-filled contents of `defaultConfig` act as base, with its `constants.configLoadFunction` property dynamically providing values to substitute. These substitutions are formatted as follows:
    ```
    {
        rootType.subtype.(...).preferenceName : value
        ...
    }
    ```
    For a full list of paths which can be overwritten, refer to the `[defaultConfig](https://github.com/Elijah-Bodden/Membrane/blob/main/lib/index.js)` object itself—it contains a preset for every possible `CONFIG` value.
    The `configLoadFunction` function runs every time the script is initialized. If the function is left undefined, or if it returns an empty object, `CONFIG` will be set equal to `defaultConfig`. If a provided path doesn't exist in `defaultConfig`, its value is discarded.
  - #### communication.packageArgs 
    An array of which arguments which must/may be included in packages sent via [`RTCDataChannel.prototype.standardSend`](https://github.com/Elijah-Bodden/Membrane#rtcdatachannelprototypestandardsend). This value helps determine the validity of recieved data packages. Entries are structured as `{ required : [...], optional: [...] }`. 

> **_NOTE:_** Optional is left open-ended by default. This means that all extranneous values in a recieved package will be allowed. To forcibly allow only arguments specified in `packageArgs`, so that anything else throws an error, include the value "`!*`" in optional.
  - #### communication.routeAcceptHeuristic
    Given a single argument—a request initiator package minus the `type` header—determines whether or not to connect to a peer. If this function is `async`, it will be automatically `await`ed, allowing asyncronous user interaction. Returns a boolean value, representing whether or not a route should be established.
- ### Prototype overrides
    This script extends two built-in prototypes, in both cases to add a specific formatting micro-protocol, and both times using unusual, unambiguous names to prevent potential future conflicts.<br><br>
    > **_NOTE:_** server reactions are specific to the signaling server used. Here it is assumed you are using the one from `/src/server`, but you can employ any custom implementation you want.
    - #### WebSocket.prototype.crudeSend
        Accepts a mandatory first argument, `type`, and an optional second, `typeArgs`—an object containing data relevant to the specific type. This data is then bundled appropriately and sent to the server. The function allows for the following types:
        - heartbeat - Sends an empty message to indicate a peer is still living for a non-native ping-pong implementation.
        - reportNode - Alerts the server that a particular peer provided invalid SDP to a node newly requesting entry. The server will increase the offender's routing weight (making it less probable it will route to it again), and provide a new route to the caller. If the node receives invalid data from different nodes three times in a row, it will throw a fatal error and stop attempting.
        - returnSDP - Returns SDP made in response to a request from the server (this will be provided, in turn, to a node newly entering the network, one half of the initial server signal).
        - ignoreSDPRequest - Like reportNode but for a node helping a prospective new peer; if the seed SDP provided by said new node is invalid, this type will be used. The server will modestly penalize the node reporting the error, and send an `["ERROR"]` package to the initial requester.
    - #### RTCDatachannel.prototype.standardSend
      Like crudeSend, this function takes either one or two arguments. However, here no checks are performed to make sure a package is properly formatted, and thus it must contain the correct data from the beginning. For a full list of possible inputs, see [CONFIG.communication.packageArgs](https://github.com/Elijah-Bodden/Membrane#communicationpackageargs). In the end, all data are bundled up and sent to the rtcDataChannel which the method is called on.
- ### EventHandlingMechanism
  This class is available globally under the variable name `eventHandler`; for more information, check out the official [kNow](https://github.com/Elijah-Bodden/kNow) repo, which was spun off of the Membrane version.
- ### AbstractMap
  Once again, see the [relevant section](https://github.com/Elijah-Bodden/Membrane#abstractmap) of Utilities for a more complete treatment of the matter. The version in `lib` differs from the utility only insofar as it also contains efficient `exportList` and `importList` methods. Export values are stored compactly inside of the `export` variable once generated. The property `exportRefreshed` conveys whether the current value of `export` accurately represents the map. The higher-level `optionalExport` method will `exportList` if and only if `exportRefreshed` is false. This class is globally instantiated as `networkMap`; this is used to find the most efficient peer routes across the network. Taking `Object.keys(networkMap.nodes)` or `Object.keys(networkMap.adjacencyList)` will render a list of all nodes within the current network.
- ### PeerConnection
  The `peerConnection` class acts as a high-level wrapper for the RTCDataChannel and RTCPeerConnection APIs, facilitating abstract interaction between nodes, such as routing and "[authenication](https://github.com/Elijah-Bodden/Membrane/blob/main/README.md#authentication)". Every connection made within this module is represented as an instance of this wrapper.
  #### SDP Exchange
  - #### PeerConnection.prototype.makeOffer
     To be called on a newly-instantiated channel; acts as a syncronous `createOffer` ICE candidate aggregator, eventually providing an SDP package appropriate to the peer's `transport.connection` and ready for exchange.
  - #### PeerConnection.prototype.receiveOffer
    Accepts a package of SDP generated by another peer's `makeOffer`, simmilarly aggregating the candidates generated by RTCPeerConnection's `createAnswer`, returning the total answer.
  - #### PeerConnection.prototype.receiveAnswer
    Accepts the answer generated by `peerConnection.prototype.receiveOffer` and commits it to the peerConnection, completing the SDP cycle and readying the connections for data exchange.
    ____ 
  - #### makeDefiniteRoute
    Accepts the hiddenAlias of an existing node within the network map and a level of `desiredPermissions`. Instantiates a new `peerConnection`, generates an offer through `makeOffer`, bundles this up into an appropriate package, and sends it via [`detatchedRoute`](https://github.com/Elijah-Bodden/Membrane/blob/main/README.md#detatchedroute) to the nearest intermediary in the route to `destination`. The function then awaits one of three outcomes—`routeAccepted`, `routeRejected`, or `routeInaccessible`, and responds accordingly, either preparing the channel for data transfer or killing it and alerting the user.
  - #### comprehendProspectiveRoute
    Accepts a complete routing package, minus the `type` header, instantiates a new peer, attempts to use the SDP contained within the package, and, assuming this action has been successful, uses [`CONFIG.communication.routeAcceptHeuristic`](https://github.com/Elijah-Bodden/Membrane/blob/main/README.md#communicationrouteacceptheuristic) on the package to determine whether or not to persist the connection and formulate a response or to terminate the initialization protocol and destroy the peer.
  - #### handleMessage
    The central drain through which all packages recieved by the peer are aggregated; the code is quite exceptionally straightforward, but would be downright tedious to display here given its length. For a precise overview of the ways messages are handled, see the [handleMessage source](https://github.com/Elijah-Bodden/Membrane/blob/e0663953d61268a475ffbc3fee5c452c2c6c65ec/lib/index.js#L851-L1021).
  - #### weaklyValidateMessage
    Returns a boolean representing whether or not a message conform to the standards outlined by [`CONFIG.communication.packageArgs`](https://github.com/Elijah-Bodden/Membrane#communicationpackageargs).
  - #### initializationMethods
    Contains the two neccessary components of a proper symmetric peer handshake, namely: 
    - `invokerIntroduction` - Used on the package type of the same name, provided by the `voluntary` peer (the one which initially "requested" the route,) this method applies several essential data proivded by the first peer, and eventually bundles up its own `reciprocalAlignment` package for this peer, containing a copy of the current networkMap, if the peer claims to need one, and its own aliases.
    - `reciprocalAlignment` - Used simmilarly; accepts and parses the aliases (and possibly networkmap) provided by its peer, eventually adding it to livePeers and completing the exchange sequence.
  - #### close
    Forcefully closes a peer, removing it from enrolled registers and ledgers and alerting the network of the death through the [`GossipTransport`](https://github.com/Elijah-Bodden/Membrane#gossiptransports).
  - #### stabilizeLink
    Called while a given node has less than two live peers. The peer will enter a loop of vigorously searching for a stable contact, preferably one as distant from it as possible, in order to reinforce the network. The sequence will halt only when no feasible, unconnected peers remain, or else the peer successfully adds another connection.
- ### Floundering
  If a peer ever becomes fully disconnected from the network, it will begin the violent `flounder` procedure, wiping its networkMap and performing a `serverHardRestart`, thus flailing around aimlessly until it is finally reentered into the network.
- ### GossipTransports
  The `GossipTransport` keeps all (contiguous) nodes syncronized and prevents total descent of the network into chaos. Gossip is the lifeblood of the network, constantly surging through the interstices, alerting the network of every slight reconfiguration. In the current implementation, `gossipTransport` (the global instantiation of `GossipTransport`) communicates two kinds of change: networkMap weight (calculated off of the routing penalties found within `CONFIG.constants.violationWeightPenalties` and typically assigned through the `shiftNodeWeight` function), and topological reconfiguration, i.e. node or edge addition or deletion. The flow of gossip is regulated by the instance's `propagationPulse`. The function defined over this interval determines exactly which kinds of gossip to commit every round. It decides this by looking at each defined `type`'s `iterModulo`; if `this.pulseIterations` (which is incremented each pulse) % `iterModulo` equals zero, that type's name will be pushed to the `propagationStack`. From here, all buffered items of gossip are aggregated into single per-type bundles and distributed throughout the network via [`propagateAll`](https://github.com/Elijah-Bodden/Membrane#propagateall).
  - #### Types
    Every gossip transport has zero or more `types`, stored within `this.types`, and registered through the `addType` method. Types allow distinct, seggregated ledgers which store gossip intended for unique purposes, allowing more fine-grained control over data distribution. Within the default Membrane, two different types are registered to `gossipTransport`: `topology` and `weight`. The former is registered with only one parameter, defaulting it to dispatch every propagation pulse. The second is also given an `iterModulo` of 100, so that it propagates once every hundred runs, or every ten seconds. Assuming a type is added successfully, `addType` will return a set of "trigger functions"—an object with two properties `addGossip`, and `remove`. `addGossip` accepts precisely one argument, the piece of data to be propagated, which will be pushed to that type's buffer and eventually dispatched. True to its name, `remove` immediately and irrevocably destroys the the type and all associated values.
  - #### Parsers
    Parsers are the perfect complements to types. As such, they are absolutely useless unless at least one member of the network has registered and actively dispatches from the corresponding type. Parsers are called over gossip both on directly adding it through `addGossip` and on recieving it through `consumeGossip`. If no parser has been defined for a recieved type, a `default` parser is used. Thos allows the gossip to continue propagation, the data has no direct interface with the node. The `addParser` function is relatively extensible, allowing fine-grained on-the-fly registry; however, because of this, it is also unusually convoluted. It only strictly requires the `type` argument, the type of gossip to apply to. However, a parser registered in this fashion is perfectly inert, less useful than even `default`. If the optional `useDefault` argument is truthy, the parser will first apply the `default` parser to the data before before later passing it to the optional `parserCallback`, if it exists. If defined, `parserCallback` is provided the entire `block`. If `useDefault` is set to true, the callback will recieve two more items, `unknown` and `committable`. The former contains complete copies of every component of the block containing data not held in "`knownFacts`"; the latter is merely a copy of `unknown` with all non-`constantArgs` stripped out of each component. The optional array value `constantArgs` specifies which pieces of data are relevant to the actual fact conveyed, so that the parser can decide whether or not it already "knows" about a particular convolution, and therefore should not gossip about it (this is helpful for packages containing variable, nonessential metadata which we would like to ignore). If this argument is ommitted, the value defaults to the `Object.keys` of the first member of the `block`. Finally, the `preliminaryVerification`, only ever used if `useDefault` is set to true, acts as an individual discriminator function, run over every member of `block`. If a given item fails, it is withheld from the buffer and entirely forgotten.
  - #### `propagateAll`
    The `propagateAll` function propagates every item of a specific type of gossip simultaneously, bundling them all up into contiguous packages. If the total size of the type's block exceeds 16 KiB, it will be split into several, equally-sized packages in order to preserve transfer speed (this issue seem particularly prevalent within the SpiderMonkey engine). After having distributed the complete block to each live peer, the type's buffer will be wiped completely clean.
- ### detatchedRoute
  This function attempts to `findNextHop` to the provided `destination` parameter. Assuming a route exists between the initiator and the destination, a package will be "standardSent" to the computed nearest intermediary using the `rest` of the parameters.
- ### makeServerLink
  This function is required to initialize network activities. Effectively, it instantiates a new, unbound peer and immediately calls makeOffer on it, eventually bundling the product of this function into a stringified, Base-64-ed version and inserting it into `CONFIG.serverLink.initBindURL` at the position of the (required) asterisk. By design, this should be inserted as a query parameter. The server will then forward this to the lowest-weighted peer connected to it, which will in turn ingest the data via `receiveOffer` and return it through `crudeSend`, to finally be consumed by the initial peer, as per the standard signaling protocol. This method additionally defines exactly how these "helper" peers are to act and how to perform server reconnects, which allow nodes to reconnect to the server and begin acting as helpers immediately after they regain connectivity to it, without needing perform a full signaled initial connect. This function ultimately returns the serverHardRestart function, which allows us to fully re-initialize.
- ### init
  In order to begin network interaction, the `init` function must be called. Its purpose is multi-fold, distilled by the following sequence. I pay particular attention to these elementary actions as this is the only function which __must__ be run top-level. After this, the network becomes self-sustaining.
  1. Config is loaded
  2. `serverLink` is generated through `makeServerLink`
  3. `gossipTransport` is instantiated and given the the types "topology" and "weight"
  4. A parser is added for topology. It is only able to track link, as opposed to node events; however, because these events imply the nodular structure so heavily, they infer both from these.
  5. A simple parser is added for weight. Alongside the standard `alias` and `weightModification`, each item must also include an `occurenceID` in order to differentiate between unique adjustments of the same kind, on the same node.
  <!-- List terminator -->
  After this sequence has successfully completed, the network will act with complete autonomy in stabilizing and routing, so that only explicit actions, such as `negotiateAgnosticAuthConnection` need to be taken.
- ### Status trackers
  This project tracks connection status centrally in two ways—`livePeers` and `authPeers`. Each is modified through the appropriate `add` or `remove` method (i.e. `addAuthPeer` and `removeAuthPeer`), and may be watched for changes with a callback via an `onXUpdated` method (i.e `onAuthPeersUpdated`). Livepeers comprises a list of all directly-connected peers, with new peers automatically appended following successful initialization exchanges, and peers on death or explicit termination. AuthPeers is a softer abstraction on this, containing the hiddenAliases, rather than actual references, of all peers which have [`advanced`](https://github.com/Elijah-Bodden/Membrane#authentication) send permissions.
- ### Authentication
  Authentication is essential to the this project's function. Within the scope of peerConnections, the term is taken in a slightly different sense from the standard cybersecurity definition. Here, if a peer is authenticated to another, this means it will readily accept `consumable` data—data intended solely for user-consumption and never used internally—from it.  
  Within Membrane networks, peers do not connect solely for the purpose of explicit data exchange; the network constantly [stabilizes](https://github.com/Elijah-Bodden/Membrane#stabilizelink) by creating redundant routes between nodes to improve fault tolerance. Therefore, authentication is a necessary formalism to show that, not only are two nodes implicitly connected, but, too, they both agree to exchange consumable data. There are three main ways to establish an authenticated route: `peerConnection.prototype.makeDefiniteRoute` with "permissions" set to "advanced," `(instance of peerConnection).requestPermissionEscalation`, again passing the value "advanced," or the more dynamic hybrid of the two--`peerConnection.prototype.negotiateAgnosticConnection`, which will perform an escalation if a route already exists to the destination, and, if not, employ the makeDefiniteRoute method.
