# Documentation
Feel free to use this official documentation as much or as little as you like as you build the applications of the future, with a little help from Membrane.
- ### Aliases
  Every peer has two `aliases` - one hidden and one public. 
  - `hiddenAliases` are internal names for peers. They're not hidden as "private" per se, but the user probably doesn't need to see them. 
  - `publicAliases` act like usernames. They don't have to be unique (if a client sees duplicates, it'll just add a (number) to the end of one) and aren't used much internally.  
###
`hiddenAliasLookup` maps `hiddenAlias`es to `publicAlias`es. `publicAliasLookup` does the opposite.
- ### Config
  - #### Loading custom configurations:
    Preferences are loaded into the `CONFIG` object when the script run. The pre-filled `defaultConfig` acts as base, with `configLoadFunction` providing selected values to swap out. These substitutions should be formatted like:
    ```
    {
        rootType.subtype.(...).preferenceName : value
        ...
    }
    ```
    (Notice that the key is a flattened version of the config location)
    For a full list of config properties, see `[defaultConfig](https://github.com/Elijah-Bodden/Membrane/blob/main/lib/index.js)`.
    If `configLoadFunction` is undefined, or returns an empty object, `CONFIG` will be set equal to `defaultConfig`. If a path doesn't exist in `defaultConfig`, its value is discarded.
  - #### communication.routeAcceptHeuristic
    Takes the contents of a request ("SDP", "sender", "destination", "routeID", possibly "desiredPermissions" (can assume that if it's not there, they want a non-authenticated connection)). Determines whether or not to connect to a peer. Returns a boolean - whether or not a route should be established. One idea is to take user input in this function. You don't have to give an immediate answer (if it's an async function it can be left hanging as long as you want).
- ### Prototype extensions
    - #### WebSocket.prototype.crudeSend
        Used for communicating with the first-contact signaling server (the thing that gets you into the network in the first place)
        Takes a `type`, and optional `typeArgs` (an object containing arguments specific to a message type). Allows for the following types:
        - heartbeat - Sends an empty message to prove the peer is still connected (and thus willing to recieve connections from new first-contacters).
        - reportNode - Alerts the server that it sent invalid SDP. Penalizes the node provided this SDP (making the server less likely to use it in the future) and provides new SDP.
        - returnSDP - Returns SDP made in response to a first-contact request (this then be sent to the first-contacting node, finalizing its connection into the network).
        - ignoreSDPRequest - Like reportNode but for a node helping a prospective new peer. Used if the SDP provided by said new node is invalid. The server will send an `["ERROR"]` package to the initial requester.
    - #### RTCDatachannel.prototype.standardSend
      Like crudeSend, this function takes either one or two arguments. For a full list of possible inputs, see [CONFIG.communication.packageArgs](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#communicationpackageargs). In the end, all data are bundled up and sent to the rtcDataChannel which the method is called on.
- ### EventHandlingMechanism
  Instantiated as `eventHandler`; for more information, check out the official [kNow](https://github.com/Elijah-Bodden/kNow) repo, which was spun off of the Membrane event handler.
- ### AbstractMap
  An efficient adjacency-list-based representation for undirected graphs. The methods for modifying edges and nodes should be self-explanatory. `precomputeRoutes` runs Dijkstra's algorithm, taking into account edge weights. After running precomputeRoutes, `findNextHop` finds the optimal next hop for a message on its way to a reciever. `exportList` and `importList` allow compact importing and exporting of graph data. The class is instantiated as `networkMap`, which is used to find the most efficient routes for communication. `Object.keys(networkMap.nodes)` or `Object.keys(networkMap.adjacencyList)` provides a list of all nodes on the network.
- ### PeerConnection
  The `peerConnection` class is a high-level wrapper for RTCDataChannel and RTCPeerConnection, facilitating interactions like routing and "[authenication](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#authentication)" between peers. Every connection made in a Membrane is represented as a `PeerConnection`.
  #### SDP Exchange
  - #### PeerConnection.prototype.makeOffer
     Syncronously collects `createOffer` ICE candidates, eventually providing an ICE offer ready for exchange.
  - #### PeerConnection.prototype.receiveOffer
    Accepts a package of SDP generated by another peer's `makeOffer` and commits it to the peerConnection, collecting candidates generated by RTCPeerConnection's `createAnswer`, and returning an answer SDP.
  - #### PeerConnection.prototype.receiveAnswer
    Accepts the answer generated by `peerConnection.prototype.receiveOffer` and commits it to the peerConnection, completing the SDP cycle and readying the connections for data exchange.
    ____ 
  - #### makeDefiniteRoute
    Accepts an existing node's hiddenAlias and a level of `desiredPermissions`. Creates a `peerConnection` and starts an ice exchange with `makeOffer`. Waits for one of three outcomes - `routeAccepted`, `routeRejected`, or `routeInaccessible`, and responds accordingly, either preparing the channel for data transfer or killing it.
  - #### comprehendProspectiveRoute
    Accepts a another peer's route offer, instantiates a new PeerConnection, and, assuming the `routePackage`'s SDP validates, calls [`CONFIG.communication.routeAcceptHeuristic`](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#communicationrouteacceptheuristic). Depending on the result, will either formulate a response or kill the PeerConnection.
  - #### initializationMethods
    Two methods used in the post-connection handshake to create a mature LivePeer. Basically just syncs the two peers up and adds them to each others LivePeers lists. 
  - #### close
    Forcefully closes a connection and and alerts the the network through the [`GossipTransport`](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#gossiptransports).
  - #### stabilizeLink
    Called when a client has less than two live peers. Searches for another peer to connect to, preferably one as far away as possible, to reinforce the network.
- ### Floundering
  If a client ever gets fully disconnected from the network, it will `flounder`, wiping its networkMap and performing a `serverHardRestart` until it's finally able to reach the server and reenter the network.
- ### GossipTransports
  The `GossipTransport` keeps the network from rapidly descending into chaos, by giving a semblence of coordination. Clients pulse gossip across the network, alerting all peers to network changes. `gossipTransport` handles two kinds of change: networkMap weight (changed when a peer earns a [penalty](CONFIG.constants.violationWeightPenalties)), and topology changes. The Gossip flow is regulated by a `propagationPulse`. Some gossip types are distributed more often than others. If it's a gossip type's turn to be distributed, its name will be pushed to the `propagationStack` and distributed in type-bundles via [`propagateAll`](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#propagateall).
  - #### Types
    Every gossip transport has zero or more `types` created with the `addType` method. Types allow separate bins which store gossip for different purposes. In Membrane, two types are registered: `topology` and `weight`. The former dispatches every propagation pulse. The latter dispatches once every hundred pulses, or every ten seconds (as it's lower priority). `addType` returns two functions - `addGossip`, and `remove`. `addGossip` accepts exactly one argument, the piece of data to propagate. `Remove` immediately and destroys the the type and all associated values.
  - #### Parsers
    Parsers interpret incoming gossip according to type. Parsers are called over gossip when the client adds its own gossip with `addGossip` and on recieving it through `consumeGossip`. If no parser has been defined for a recieved type, a `default` parser is used. The default parser passes the gossip along but doesn't do anything with it itself. 
  - #### `propagateAll`
    The `propagateAll` propagates every item of a specific type of gossip, bundling them all up into contiguous packages. If the combined pieces of a type of gossip exceed 16 KiB, the bundle will be split into several equally-sized packages.
- ### detatchedRoute
  Tries to complete the next step in (potentially multi-step) a package delivery. Tries to `findNextHop` to the `destination` node. If a route exists, the package will be `standardSent` to said next step.
- ### makeServerLink
  The initial, server-based route needed to join the network. Sends an initial SDP as a parameter on a WS connection to `CONFIG.serverLink.initBindURL`. The server will send this to its favorite peer, which will recieve the offer and send its response to the server, which will pass it on to the initiator, patching it into the network.
- ### init
  Initializes a Membrane peer. Once this is called, the client should function on its own in the background. After this it should only need interaction for explicit actions like as `negotiateAgnosticAuthConnection`.
- ### Status trackers
  The client tracks its connections `livePeers` and `authPeers`. Each can be modified with an `add` or `remove` method (e.g. `addAuthPeer` and `removeAuthPeer`), and can be watched for changes with an `onXUpdated` method (e.g `onAuthPeersUpdated`). Livepeers lists all nodes the client has a direct connection to. AuthPeers lists all connected peers that have [`advanced`](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#authentication) send permissions.
- ### Authentication
  In membrane, authenticated peers are peers that the client has agreed to recieve `consumable` packages from.  
  In Membrane networks, peers don't only connect to exchange data; the network constantly [stabilizes](https://github.com/Elijah-Bodden/Membrane/blob/main/docs.md#stabilizelink) by creating redundant likes. Therefore, a connection doesn't immediately mean a client wants to interact with a peer (i.e. receive consumable packages). It might just be a link for routing purposes. There are three main ways to establish an authenticated route: `peerConnection.prototype.makeDefiniteRoute` with "permissions" set to "advanced," `(instance of peerConnection).requestPermissionEscalation`, again passing the value "advanced," or `peerConnection.prototype.negotiateAgnosticConnection`, which will try to escalate permissions if route already exists to the destination, and try to create an "advanced" connection with makeDefiniteRoute if no connection exists.
